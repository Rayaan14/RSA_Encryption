#lang racket
(require loudhum)

;;; Procedure:
;;;   prime?
;;; Parameters:
;;;   num, a positive number
;;; Purpose:
;;;   determines if num is a prime number
;;; Produces:
;;;   isprime, a boolean value (#t or #f)

(define prime?
  (lambda (num)
    (let ([root (inexact->exact (truncate (expt num 0.5)))])
      (cond
        [(< num 2) #f]        
        [else
         (not (any zero? (map (section remainder num <>) (range 2 (+ 1 root)))))]))))

;;; Procedure:
;;;   random-elt
;;; Parameters:
;;;   lst, a non-empty list 
;;; Purpose:
;;;   unpredictably pick an element of lst
;;; Produces:
;;;   val, a value

(define random-elt
  (lambda (lst)
    (list-ref lst (random (- (length lst) 1)))))

;;; Procedure:
;;;   first-coprime
;;; Parameters:
;;;   int, an integer
;;; Purpose:
;;;   finds the smallest number greater than 0 that is co-prime to a given integer
;;; Produces:
;;;   cint, a small integer

(define first-coprime
  (lambda (int)        
    (let kernel ([count 2])
      (if (= (gcd int count) 1)
          count
          (kernel (+ 1 count))))))

;;; Procedure:
;;;   determine-d
;;; Parameters:
;;;   p, a random prime number generated by the generate-keys procedure, an integer.
;;;   q, a random prime number generated by the generate-keys procedure, an integer.
;;;   e, the result of calling first-coprime on (* p q)
;;; Purpose:
;;;   computes d, the private key exponent used for the RSA Encryption Algorithm
;;; Produces:
;;;   val, an integer

(define determine-d
  (lambda (p q e)
    (let ([n (* p q)]
          [totient (* (- p 1) (- q 1))])
      (let kernel ([k 0])
        (if (integer? (/ (+ 1 (* k totient)) e))
            (/ (+ 1 (* k totient)) e)
            (kernel (+ k 1)))))))

;;; Procedure:
;;;   generate-keys
;;; Parameters:
;;;   [None]
;;; Purpose:
;;;   generates all the elements of the public and private keys necessary for the RSA Encryption Method
;;; Produces:
;;;   keyfile, a file with the name "key-list.txt" consisting of 5 integers

;;; Note: The file address in generate-keys will need to be changed to a local directory on your computer

(define generate-keys
  (lambda ()
    (let* ([primes (filter prime? (range 100 1000))]
           [p (random-elt primes)]
           [q (let ([rq (random-elt primes)])
                (if (= p rq) (random-elt primes) rq))]
           [n (* p q)]
           [totient (* (- p 1) (- q 1))]
           [e (first-coprime totient)]
           [d (determine-d p q e)])
      (string->file (reduce string-append (map (section string-append <> " ") (map number->string (list n p q e d)))) "/Users/Rayaan/Desktop/CSProject/key-list.txt")
      )))

;;; Procedure:
;;;   my_expt
;;; Parameters:
;;;   x, a base number
;;;   n, the exponent, an integer
;;; Purpose:
;;;   computes x raised to n using the square-and-multiply algorithm
;;; Produces:
;;;   enum, a real number

;;; Citation: https://en.wikipedia.org/wiki/Exponentiation_by_squaring

(define my_expt
  (lambda (x n)
    (cond
      [(zero? n) 1]
      [(= n 1) x]
      [(even? n) (my_expt (* x x) (/ n 2))]
      [else (* x (my_expt (* x x) (/ (- n 1) 2)))])))

;;; Procedure:
;;;   pad-with-zeros
;;; Parameters:
;;;   str, a string
;;;   n, a desired length
;;; Purpose:
;;;   Puts 0's at the front of str so that the result is
;;;   n characters long.
;;; Produces:
;;;   padded, a string
;;; Preconditions:
;;;   string-length str <= n
;;; Postconditions:
;;;   * (string-length padded) = n
;;;   * (regexp-match-exact? (regexp (string-append "0*" str)) padded)

;;; Citation: http://www.cs.grinnell.edu/~hamidfah/courses/csc151spring2019//readings/structs.html

(define pad-with-zeros
  (lambda (str n)
    (string-append (make-string (- n (string-length str)) #\0) str)))

;;; Procedure:
;;;   encryption
;;; Parameters:
;;;   n, a product of two prime numbers, an integer
;;;   e, the result of calling first-coprime on (* p q)
;;;   str, a string
;;; Purpose:
;;;   encrypts str according to the RSA Algorithm
;;; Produces:
;;;   elst, a list of numbers 

(define encryption
  (lambda (n e string)
    (let* ([string-sep (string->list string)]
           [char-conv (map char->integer string-sep)]
           [encrypt (lambda (number) (modulo (my_expt number e) n))])
      (map encrypt char-conv))))

;;; Procedure:
;;;   encipher
;;; Parameters:
;;;   str, a string
;;; Purpose:
;;;   * encrypt str according to the RSA algorithm to generate a list of numbers
;;;   * add 0s to the beginning of each resulting number to ensure they are of the same length
;;;   * combine the numbers end-to-end into a larger number and convert the result into a string
;;; Produces:
;;;   numstr, a large string consisting of numerical digits
;;; Preconditions:
;;;   str should consist of valid ASCII characters
;;; Postconditions:
;;;   * (string? numstr)
;;;   * (string-length numstr) = (* 10 (string-length str))

(define encipher
  (lambda (str)
    (if (not (string? str))
        (error "Expected string, given " str)
        (reduce string-append (map (section pad-with-zeros <> 10)
                                   (map number->string (encryption
                                                        (list-ref (map cdr (file-convert)) 0)
                                                        (list-ref (map cdr (file-convert)) 3) str)))))))


;;; Procedure:
;;;   numsplit
;;; Parameters:
;;;   str, a string such that (remainder (string-length str) 10) = 0
;;; Purpose:
;;;   splits str 10 characters at a time into a list
;;; Produces:
;;;   slst, a list of strings

(define numsplit
  (lambda (str)
    (if (zero? (string-length str))
        null
        (cons (substring str 0 10) (numsplit (substring str 10 (string-length str)))))))

;;; Procedure:
;;;   file-convert
;;; Parameters:
;;;   [None]
;;; Purpose:
;;;   reads the key-list file and outputs a list consisting of the 5 key-value pairs
;;; Produces:
;;;   klst, a list of pairs

;;; Note: The file address in file-convert will need to be changed to a local directory on your computer

(define file-convert
  (lambda ()
    (map cons (list "n" "p" "q" "e" "d")
         (map string->number (string-split (file->string "/Users/Rayaan/Desktop/CSProject/key-list.txt"))))))

;;; Procedure:
;;;   decryption
;;; Parameters:
;;;   n, a product of two prime numbers, an integer
;;;   d, the private key exponent
;;;   numstr, a string consisting of numerical digits
;;; Purpose:
;;;   decrypts numstr according to the RSA Algorithm
;;; Produces:
;;;   secretstr, a string

(define decryption
  (lambda (n d numstr)
    (let* ([decrypt (lambda (number) (modulo (my_expt number d) n))])
      (list->string (map integer->char (map decrypt (map string->number (numsplit numstr))))))))

;;; Procedure:
;;;   decipher
;;; Parameters:
;;;   numstr, a string consisting of numerical digits
;;; Purpose:
;;;   decrypt numstr according to the RSA algorithm to generate its corresponding string
;;; Produces:
;;;   secretstr, a string
;;; Preconditions:
;;;   numstr is the result of running encipher on secretstr
;;; Postconditions:
;;;   * (string? secretstr)
;;;   * (string-length secretstr) = (/ (string-length numstr) 10)

(define decipher
  (lambda (numstr)
    (decryption (list-ref (map cdr (file-convert)) 0) (list-ref (map cdr (file-convert)) 4) numstr)))

#| Removing Manual Secret String (Encrypted Message) Entry

Our group thought that this may have some practical uses, as it may be annoying to
copy and paste the encrypted message manually for the receiver. This method would
not be practical for one-time use, but could be useful for sustained communication
between the same sender and receiver.

Changes:
1) Encipher deposits the encrypted message into a designated file, "filename", that the sender may edit
   to fit their computer setup.
2) The receiver downloads the aforementioned file through email or some other source. They edit "filename"
   to reflect the file's location on the receiver's computer.
3) The deceyption procedure extracts the entered file (as required by the decipher parameters), thus removing
   the necessicity to copy and paste the encrypted message.

Ultimately, these changes would be useful once the sender and receiver have put in the time to setup the file,
as a new message will simply replace the previous encrypted message file. When the receiver downloads the file,
and if the name of the file is the same, all they would have to do is replace the old file with the new in the
pre-setup directory. As this is for sustained use, this method is not recommended for one-time users.

To use this method, copy and paste the code below to replace the respective existing code:

(define encipher
  (lambda (str)
    (if (not (string? str))
        (error "Expected string, given " str)
        (string->file (reduce string-append (map (section pad-with-zeros <> 10)
                                   (map number->string (encryption
                                                        (list-ref (map cdr (file-convert)) 0)
                                                        (list-ref (map cdr (file-convert)) 3) str)))) "filename"))))

(define decryption
  (lambda (n d filename)
    (let* ([decrypt (lambda (number) (modulo (my_expt number d) n))])
      (list->string (map integer->char (map decrypt (map string->number (numsplit (file->string filename)))))))))

(define decipher
  (lambda (filename)
    (decryption (list-ref (map cdr (file-convert)) 0) (list-ref (map cdr (file-convert)) 4) filename)))

|#
